# Replit Agent: Fix API Contract Alignment

## Context
The game engine is working! Now we need to align the API routes between client and server. Currently there's a mismatch: the client expects different endpoints than what the server provides.

## Current Issues:
1. **Client hooks use hard-coded game IDs**
2. **API contracts don't match server routes**
3. **Some endpoints exist in contracts but not in server**

## Task 1: Standardize API Routes

### Current Mismatches:
```
Contract expects ‚Üí Server has
/api/advance-month ‚Üí /api/games/:id/advance-month
/api/select-actions ‚Üí /api/games/:gameId/actions
/api/game-state ‚Üí /api/games/:id (GET)
```

### Decision: Use RESTful Pattern
We'll use the RESTful pattern that's clearer for AI assistants and scalable:
```
/api/games/:gameId/[resource]
```

### Please Update shared/api/contracts.ts:

```typescript
import { z } from 'zod';
import { GameStateSchema, MonthlyActionSchema } from '../schema';

// API Response schemas
const ApiResponseSchema = z.object({
  success: z.boolean(),
  data: z.any().optional(),
  error: z.string().optional(),
});

// Game endpoints
export const gameEndpoints = {
  // Game state
  getGame: '/api/games/:gameId',
  createGame: '/api/games',
  saveGame: '/api/games/:gameId',
  
  // Game actions
  advanceMonth: '/api/games/:gameId/advance-month',
  selectActions: '/api/games/:gameId/actions',
  
  // Game resources
  getArtists: '/api/games/:gameId/artists',
  getProjects: '/api/games/:gameId/projects',
  getRoles: '/api/games/:gameId/roles',
  
  // Dialogues
  getDialogue: '/api/games/:gameId/dialogues/:dialogueId',
  selectChoice: '/api/games/:gameId/dialogues/:dialogueId/choices/:choiceId',
};

// Request/Response types
export const AdvanceMonthRequest = z.object({
  gameId: z.string(),
});

export const AdvanceMonthResponse = z.object({
  success: z.boolean(),
  gameState: GameStateSchema,
  summary: z.object({
    month: z.number(),
    changes: z.array(z.any()),
    revenue: z.number(),
    expenses: z.number(),
    reputationChanges: z.record(z.number()),
    events: z.array(z.any()),
  }),
});

export const SelectActionsRequest = z.object({
  gameId: z.string(),
  actions: z.array(MonthlyActionSchema),
});

export type GameEndpoints = typeof gameEndpoints;
```

## Task 2: Update API Client

Update `shared/api/client.ts` to handle the gameId properly:

```typescript
class APIClient {
  private baseURL: string;
  private gameId: string | null = null;

  constructor(baseURL: string = '') {
    this.baseURL = baseURL;
  }

  setGameId(gameId: string) {
    this.gameId = gameId;
  }

  private replaceParams(endpoint: string, params: Record<string, string> = {}): string {
    let url = endpoint;
    
    // Auto-inject gameId if available
    if (this.gameId && url.includes(':gameId')) {
      params.gameId = this.gameId;
    }
    
    // Replace all :param with actual values
    Object.entries(params).forEach(([key, value]) => {
      url = url.replace(`:${key}`, value);
    });
    
    return url;
  }

  async get<T>(endpoint: string, params?: Record<string, string>): Promise<T> {
    const url = this.replaceParams(endpoint, params);
    const response = await fetch(`${this.baseURL}${url}`);
    if (!response.ok) {
      throw new Error(`API Error: ${response.statusText}`);
    }
    return response.json();
  }

  async post<T>(endpoint: string, data: any, params?: Record<string, string>): Promise<T> {
    const url = this.replaceParams(endpoint, params);
    const response = await fetch(`${this.baseURL}${url}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data),
    });
    if (!response.ok) {
      throw new Error(`API Error: ${response.statusText}`);
    }
    return response.json();
  }
}

export const apiClient = new APIClient();
```

## Task 3: Create GameContext for gameId

Create a new file `client/src/contexts/GameContext.tsx`:

```typescript
import React, { createContext, useContext, useState, useEffect } from 'react';
import { apiClient } from '../../shared/api/client';

interface GameContextType {
  gameId: string | null;
  setGameId: (id: string) => void;
}

const GameContext = createContext<GameContextType | undefined>(undefined);

export function GameProvider({ children }: { children: React.ReactNode }) {
  const [gameId, setGameId] = useState<string | null>(null);

  useEffect(() => {
    // Get gameId from URL or localStorage
    const urlParams = new URLSearchParams(window.location.search);
    const idFromUrl = urlParams.get('gameId');
    const idFromStorage = localStorage.getItem('currentGameId');
    
    const id = idFromUrl || idFromStorage || 'demo-game';
    setGameId(id);
    
    // Update API client
    apiClient.setGameId(id);
  }, []);

  const updateGameId = (id: string) => {
    setGameId(id);
    apiClient.setGameId(id);
    localStorage.setItem('currentGameId', id);
  };

  return (
    <GameContext.Provider value={{ gameId, setGameId: updateGameId }}>
      {children}
    </GameContext.Provider>
  );
}

export function useGameContext() {
  const context = useContext(GameContext);
  if (!context) {
    throw new Error('useGameContext must be used within GameProvider');
  }
  return context;
}
```

## Task 4: Update React Query Hooks

Update the hooks in `client/src/features/game-state/hooks/` to use the gameEndpoints and GameContext:

Example for `useAdvanceMonth.ts`:
```typescript
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { apiClient } from '../../../../shared/api/client';
import { gameEndpoints } from '../../../../shared/api/contracts';
import { useGameContext } from '../../../contexts/GameContext';

export function useAdvanceMonth() {
  const queryClient = useQueryClient();
  const { gameId } = useGameContext();

  return useMutation({
    mutationFn: async () => {
      if (!gameId) throw new Error('No game ID');
      
      return apiClient.post(
        gameEndpoints.advanceMonth,
        {},
        { gameId }
      );
    },
    onSuccess: (data) => {
      // Invalidate and update game state
      queryClient.setQueryData(['game', gameId], data.gameState);
      queryClient.invalidateQueries({ queryKey: ['game', gameId] });
    },
  });
}
```

## Task 5: Wrap App with GameProvider

Update `client/src/App.tsx`:
```typescript
import { GameProvider } from './contexts/GameContext';

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <GameProvider>
        {/* existing app content */}
      </GameProvider>
    </QueryClientProvider>
  );
}
```

## Verification Steps

After making these changes:
1. Check TypeScript compilation: `npx tsc --noEmit`
2. Test that the client can connect to server endpoints
3. Verify advancing month works from the UI
4. Check that gameId is properly passed to all API calls
5. Ensure no more hard-coded game IDs in hooks

## Expected Outcome

Once complete:
- ‚úÖ API contracts will match server implementation
- ‚úÖ gameId will be managed centrally via Context
- ‚úÖ All API calls will use consistent endpoints
- ‚úÖ Client-server communication will be properly typed
- ‚úÖ No more hard-coded IDs

Please report:
- ‚úÖ Which files were updated
- üìù Any endpoints that needed adjustment
- ‚ùå Any TypeScript errors
- üîå Whether client-server communication works